[
["index.html", "Lösningar i R (samt lite annat kul) 1 Introduktion 1.1 Motivering 1.2 Varför R?", " Lösningar i R (samt lite annat kul) Erik Stenberg 2018-04-16 1 Introduktion 1.1 Motivering Detta dokument är till för dig som läser kursen Statistik A4/A8 och är nyfiken på R. Innehållet är tänkt att förena lite nytta (lösa uppgifter) med nöje (lära dig lite R). Innehållet är inte på något sätt någonting du förväntas lära dig under kursen, men kan komma att vara nyttigt om du tänkt fortsätta med studier i statistik. Det är inte heller meningen att detta dokument skall fungera som en heltäckande introduktion till programmeringsspråket R. Det finns mängder väldigt välskrivna guider online som fokuserar mycket mer på hur språket är uppbygt. Lyckligtvis är R väldigt enkelt att komma igång med, och det krävs inte mycket förståelse för strukturer för att göra enkla beräkningar, skattningar av modeller, rita grafer och göra hypotestester. Jag rekommenderar att du hittar en guide Youtube eller i bokform för att komma igång med R. Tänk på att många guider online är riktade mot människor med en bakgrund i programmering. Försök hitta en guide på din nivå. R är programmeringsspråket vi kommer använda, och vi kommer göra allt arbete i RStudio, som är en IDE (Integrated Developer Environment) för R. RStudio gör arbete med R mycket enklare. Du behöver både R och RStudio på din egen dator, eller använda någon av datorerna i labben. 1.2 Varför R? R och RStudio är gratis, populärt och enkelt att komma igång med. Det är framtaget framför allt för statistiska beräkningar och visualiseringar. Under det senaste årtiondet har populariteten växt enormt och i dag är R ett av de absolut mest använda verktygen för data-analys, både ute i verkligheten och inom universitetsvärlden. Om du någon gång tänkt skriva en uppsats i statistik, företagsekonomi nationalekonomi, eller någonting kvantitativt i vilket ämne som helst, kan R vara en bra vän att ha. library(fortunes) fortune(&#39;subway&#39;) ## ## Soon, they&#39;ll be speaking R on the subway. ## -- Michael Rennie (giving &#39;Kudos to the R support team&#39;) ## R-help (July 2004) "],
["kom-igang.html", "2 Kom igång 2.1 Viktiga funktioner 2.2 Funktioner och paket", " 2 Kom igång 2.1 Viktiga funktioner Jag förutsätter att du har R och RStudio installerat (eller sitter vid någon av datorerna statistik-labbarna). Som tidigare nämnts så kommer detta inte vara någon genomgående guide till R, men det finns ett par saker som är viktiga att nämna innan vi kör igång. Skriver du 1+1 så kommer R ge dig 2. 1+1 ## [1] 2 Du kan också skapa ett objekt med &lt;- som kallas the assign operator. x &lt;- 1+1 Notera att R inte kommer skriva ut vad x är förrän du ber om det x ## [1] 2 I detta dokument kommer resultat från R alltid föregås av ##. Det är så du kan se skillnad på vad jag skriver och vad R ger tillbaka. Ibland kommer du även se enskilda # i koden. Allting som skrivs efter # behandlas av R som icke-kod. Det vill säga, jag kommer ofta använda # kommentar i koden för att förtydliga någonting jag gör. Vektorer är den absolut vanligaste datatypen i R, och du kommer vid flera tillfällen behöva skapa vektorer. Ofta skapar vi vektorer med funktionen c(). För att se om ett objekt är en vektor använder du med framgång is.vector. x &lt;- c(1,5,7,2,4,6,7) is.vector(x) ## [1] TRUE I detta fallet är x alltså en numerisk vektor, men det finns andra sorter. y &lt;- c(&quot;R&quot;,&quot;är&quot;,&quot;kul&quot;) is.vector(y) ## [1] TRUE is.numeric(y) ## [1] FALSE is.character(y) ## [1] TRUE y är alltså en character vector. Dessa objekt kommer i vårt fall ofta vara stickprov. Låt säga att vi har frågat några personer om deras längd. stickprov &lt;- c(170, 165, 151, 191, 180, 172, 181, 166, 155, 194, 166, 175, 144, 188, 192, 164, 178, 201) Vi kan enkelt hitta stickprovsstorlek, medelvärde, standardavvikelse och skapa ett histogram length(stickprov) # stickprovsstorlek ## [1] 18 mean(stickprov) # medelvärde ## [1] 174.0556 sd(stickprov) # standardavvikelse ## [1] 15.64109 hist(stickprov) Låt säga att jag har två vektorer, en med namn på universitet och en med antal studenter (enligt wikipedia). Men jag vill ha dem i samma objekt. Då skapar jag med fördel en såkallad dataframe. namn &lt;- c(&quot;UU&quot;, &quot;KTH&quot;, &quot;SU&quot;, &quot;LU&quot;) studenter &lt;- c(24623, 12000, 29087, 40000) z &lt;- cbind.data.frame(namn,studenter) is.vector(z) # z är inte längre en vektor ## [1] FALSE is.data.frame(z) # z är en data frame ## [1] TRUE Så hur ser z ut? z ## namn studenter ## 1 UU 24623 ## 2 KTH 12000 ## 3 SU 29087 ## 4 LU 40000 För att “komma åt” data från en dataframe kan jag använda $. z$studenter ## [1] 24623 12000 29087 40000 Eftersom z$studenter är en numerisk vektor kan jag göra precis samma sak på z$studenter som jag kunde göra på stickprovet ovan. mean(z$studenter) ## [1] 26427.5 sd(z$studenter) ## [1] 11585.83 Skulle jag försöka göra samma sak på z$namn får jag en varning och resultatet blir NA. Jag kan naturligtvis inte räkna ut medelvärdet av fyra namn. mean(z$namn) ## Warning in mean.default(z$namn): argument is not numeric or logical: ## returning NA ## [1] NA 2.2 Funktioner och paket En sak som är bra med RStudio är att det finns väldigt bra dokumentation utan att du behöver gå till din webbläsare. Om du undrar hur en funktion fungerar så räcker det ofta med att skriva ett frågetecken följt av funktionens namn, ex: ?mean, och en hjälp-sida visas i din “viewer pane” till höger. Längst ner på hjälp-sidan finns ofta enkla exempel. Många funktioner i R kommer från externa paket. Vissa av dem är otroligt enkla att använda, andra tar lång tid att lära sig. Vem som helst kan skriva ett paket, och de är enkla att installera. Det finns otroligt många paket, och användningsområdena är nästan lika många. För att demonstrera hur installation av ett paket går till kan vi titta på ett paket som heter gapminder, som innehåller data tillänglig på Gapminder.org. Första gången du använder ett paket behöver du installera det. Det gör du genom att skriva install.packages(&quot;gapminder&quot;) Observera citationstecken. Detta behöver du bara göra en gång på din dator. När du vill använda paketet i framtiden måste du, varje gång du öppnar RStudio, skriva library(gapminder) Paketet gapminder är ett litet paket och innehåller inga funktioner, bara dataset. Ett av dataseten heter gapminder och innehåller data på bland annat förväntad linvslängd, population, BNP etc. Du laddar ner datan genom att helt enkelt skriva gapminder ## # A tibble: 1,704 x 6 ## country continent year lifeExp pop gdpPercap ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Afghanistan Asia 1952 28.8 8425333 779. ## 2 Afghanistan Asia 1957 30.3 9240934 821. ## 3 Afghanistan Asia 1962 32.0 10267083 853. ## 4 Afghanistan Asia 1967 34.0 11537966 836. ## 5 Afghanistan Asia 1972 36.1 13079460 740. ## 6 Afghanistan Asia 1977 38.4 14880372 786. ## 7 Afghanistan Asia 1982 39.9 12881816 978. ## 8 Afghanistan Asia 1987 40.8 13867957 852. ## 9 Afghanistan Asia 1992 41.7 16317921 649. ## 10 Afghanistan Asia 1997 41.8 22227415 635. ## # ... with 1,694 more rows Ett annat paket som, likt de flesta andra paket, faktiskt innehåller flera funktioner är stats som innehåller funktioner för statistiska beräkningar med mera. Här är ett par exempel funktioner. stats är förinstallerat och igång vid uppstart, så du behöver varken installera det med install.packages(&quot;stats&quot;) eller skriva library(stats). Ett exempel på funktioner i stats är rnorm() som genererar slumpmässiga tal från normalfördelningen. rnorm(n = 5, mean = 0, sd = 1) ## [1] 0.1696365 -0.7840147 0.8438367 1.7595717 0.6021140 n, mean och sd är stickprovsstorlek, medelvärde och standardavvikelse respektive. De kallas argument. Funktionen rnorm() har bara dessa tre argument, och de behöver inte skrivas ut. Det vill säga, så länge du håller koll på i vilken ordning argumenten kommer så kan du lika gärna skriva rnorm(5,0,1) # Ger oss alltså fem slumpmässiga nummer från N(0,1) ## [1] -1.558325277 2.367060878 -1.518652373 0.006873676 0.677454884 Ofta har funktionerna ett “default” värde. Det vill säga, ett värde på argumentet om du inte själv specifierar det. I fallet rnorm() kan du säkert gissa dig till vilket medelvärde och vilken standardavvikelse som är default, nämligen mean=0 och sd=1, det vill säga Z-fördelningen. Stickprovsstorlek har däremot inget default, och måste specifieras manuellt. rnorm(5) ## [1] 0.8452033 0.4663501 0.8586166 0.1213616 1.1288426 Låt oss ta ett större stickprov, spara resultatet som x och skapa ett histogram, med funktionen hist(). x &lt;- rnorm(100000) hist(x) Lek runt lite med de olika argumenten. För en full lista med alla argument, titta på hjälpsidan genom ?hist hist(x, breaks = 100, col = &quot;pink&quot;, ylab = &quot;text på y-axeln&quot;, xlab = &quot;text på x-axeln&quot;, main = &quot;Stickprov om 100,000 från N(0,1)&quot;) "],
["ovningskompendium-deskriptiv-statistik.html", "3 Övningskompendium Deskriptiv Statistik 3.1 Deskription 3.2 Spridningsdiagram och Korrelation 3.3 Tidsserier", " 3 Övningskompendium Deskriptiv Statistik 3.1 Deskription Uppgift 16 betyg &lt;- c(1, 4, 4, 3, 2, 3, 3, 3, 5, 2, 3, 3, 3, 2, 4, 4, 3, 1, 2, 5, 3, 3, 4, 2, 3, 4, 2, 3) mean(betyg) ## [1] 3 median(betyg) ## [1] 3 Det finns faktiskt ingen inbyggd funktion i R för typ-värde(!), men vi kan använda table() för att hitta vad vi söker. 3 förekommer 12 gånger. table(betyg) ## betyg ## 1 2 3 4 5 ## 2 6 12 6 2 x &lt;- table(betyg) barplot(x) Uppigift 17 husdjur &lt;- c(rep(0,20), rep(1,15), rep(2,10), rep(3,5)) mean(husdjur) ## [1] 1 median(husdjur) ## [1] 1 x &lt;- table(husdjur) plot(cumsum(x), # cumsum för cumulative sum type = &quot;S&quot;, # &quot;S&quot; för &quot;steps&quot; xlim = c(0,4), # Undre och övre gräns för x ylim = c(0,50), # Undre och övre gräns för y xlab = &quot;Antal Husdjur&quot; , # Text på x-axeln ylab = &quot;Summa Antal Familjer&quot;) # Text på y-axeln segments(x0 = 0, y0 = 0, x1 = 0, y1 = 20) segments(x0 = 0, y0 = 20, x1 = 1, y1 = 20) segments(x0 = 0, y0 = 25,x1 = 1, y1 = 25,col = &quot;red&quot;,lwd=2,lty = 6) arrows(x0 = 1,y0 = 25,x1 = 1,y1 = 0, col = &quot;red&quot;,lwd=2, lty = 6) Uppgift 18 löner &lt;- c(341000, 193000, 167000, 167000, 156000, 154000, 148000, 148000, 148000, 148000) mean(löner) ## [1] 177000 median(löner) ## [1] 155000 table(löner) ## löner ## 148000 154000 156000 167000 193000 341000 ## 4 1 1 2 1 1 barplot(table(löner)) # Sned fördelning -&gt; använd median Uppgift 21 Vi har följande tabell Antal Olycksfall per dag Frekvens 0 21 1 18 3 10 4 1 Givetvis kan vi skapa vektorn och använda mean()och sd() tabell &lt;- c(rep(0,21),rep(1,18),rep(2,7),rep(3,3),rep(4,1)) mean(tabell) ## [1] 0.9 var(tabell) ## [1] 0.9897959 Men säg att vi hade fått en stor dataframe, och det hade varit för mycket jobb för att skriva en massa rep(). Det vill säga, säg att någon gav oss df nedan df &lt;- as.data.frame(cbind(c(0,1,2,3,4),c(21,18,7,3,1))) colnames(df) &lt;- c(&quot;olycksfall&quot;, &quot;frekvens&quot;) df ## olycksfall frekvens ## 1 0 21 ## 2 1 18 ## 3 2 7 ## 4 3 3 ## 5 4 1 Istället för att återskapa tabell ovan (som förvisso är väldigt enkelt - bara använd table()), så kan vi gå den långa vägen och använda. \\[\\bar{x} = \\frac{\\sum{f_i x_i}}{n}\\] \\[s^2 = \\frac{\\sum{f_i x_i^2}-\\frac{\\sum{(f_i x_i)}^2}{n}}{n-1}\\] n &lt;- sum(df$frekvens) f = df$frekvens x = df$olycksfall medelvärde = sum(f*x)/n varians = (sum(f*x^2) - sum((f*x))^2/n) / (n-1) medelvärde ## [1] 0.9 varians ## [1] 0.9897959 3.2 Spridningsdiagram och Korrelation Uppgift 101 x &lt;- as.data.frame(cbind(c(5500,6000,6500,6000,5000,6500,4500,5000), c(41,38,35,40,44,38,45,42))) colnames(x) &lt;- c(&quot;Pris&quot;,&quot;Försäljning&quot;) Vilket ger oss följande dataframe head(x) ## Pris Försäljning ## 1 5500 41 ## 2 6000 38 ## 3 6500 35 ## 4 6000 40 ## 5 5000 44 ## 6 6500 38 Korrelationsmatris cor(x) ## Pris Försäljning ## Pris 1.0000000 -0.9426412 ## Försäljning -0.9426412 1.0000000 Notera att vi egentligen inte behöver skriva type=&quot;p&quot; i plot() nedan, eftersom detta är default när man använder funktionen på objekt som x. plot(x, type= &quot;p&quot; , xlab = &quot;Pris (kr)&quot;, ylab = &quot;Försäljning (antal)&quot;, pch=16) # För at få prickarna ifyllda Gör precis samma sak för uppgift 102 Uppgift 105 dat &lt;- cbind.data.frame(1:12, c(3,4,6,2,5,6,5,4,7,6,5,4), c(14,23,25,17,30,44,35,34,39,32,38,29), c(23,30,29,26,35,58,30,50,55,45,44,34)) colnames(dat) &lt;- c(&quot;person&quot;,&quot;X&quot;,&quot;Y&quot;,&quot;Z&quot;) Z &lt;- dat$Z Y &lt;- dat$Y Såhär ser vår dataframe ut head(dat) ## person X Y Z ## 1 1 3 14 23 ## 2 2 4 23 30 ## 3 3 6 25 29 ## 4 4 2 17 26 ## 5 5 5 30 35 ## 6 6 6 44 58 Korrelationsmatris igen cor(dat) ## person X Y Z ## person 1.0000000 0.3634301 0.6489737 0.5587045 ## X 0.3634301 1.0000000 0.7407156 0.6456707 ## Y 0.6489737 0.7407156 1.0000000 0.8650861 ## Z 0.5587045 0.6456707 0.8650861 1.0000000 Vi ser att Y verkar ha högst korrelation med X, ungefär \\(0.74\\). Linjär regression i R är enkelt. I funktionen lm() anger du vilken data du vill använda, i vårt fall data = dat, formulan skrivs på formen formula = y~z. Ett intercept skattas per default, men kan undvikas genom att skriva -1 i formulan, i.e y~x-1. lm(Y ~ Z, dat) ## ## Call: ## lm(formula = Y ~ Z, data = dat) ## ## Coefficients: ## (Intercept) Z ## 4.7390 0.6604 plot(Z, Y, pch=16) abline(lm(Y ~ Z, dat), col=&quot;red&quot;) Uppgift 107 Förbered data res &lt;- cbind.data.frame(c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;), c(11.2, 11.4, 10.8, 10.9, 11.0 , 11.3), c(676, 660, 685, 670, 690, 669)) colnames(res) &lt;- c(&quot;pers&quot;,&quot;löp&quot;,&quot;hopp&quot;) Beräkningar cor(res$löp,res$hopp) ## [1] -0.695163 summary(res$löp) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 10.80 10.93 11.10 11.10 11.28 11.40 summary(res$hopp) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 660.0 669.2 673.0 675.0 682.8 690.0 y &lt;- res$löp x &lt;- res$hopp plot(x,y, xlim = c(650,700), ylim = c(10,12), pch = 16, ylab = &quot;Löp (sek)&quot;, xlab = &quot;Hopp (cm)&quot;) 3.3 Tidsserier Uppgift 401 y &lt;-c(0.175, 0.249, 0.279, 0.376, 0.528, 0.781, 1.123, 1.681, 3.131) t &lt;- 1970:1978 - 1974 lm(y~t) ## ## Call: ## lm(formula = y ~ t) ## ## Coefficients: ## (Intercept) t ## 0.9248 0.3035 Uppgift 402 y &lt;-c(0.175, 0.249, 0.279, 0.376, 0.528, 0.781, 1.123, 1.681, 3.131) y &lt;- ts(y, start = 1970, end = 1978, frequency = 1) plot.ts(y) Vi försöker igen med en expoentiell trend. y_prime = log(y,base = 10) lm(y_prime~t) ## ## Call: ## lm(formula = y_prime ~ t) ## ## Coefficients: ## (Intercept) t ## -0.2170 0.1504 För att få tillbaka vårt önskade resulat (se lösningarna för detaljer) så löser vi m &lt;- lm(y_prime~t) 10^m$coefficients ## (Intercept) t ## 0.6067278 1.4139314 "],
["ovningskompendium-sannolikhetslara-och-inferens.html", "4 Övningskompendium Sannolikhetslära och Inferens 4.1 Sannolikhetslära 4.2 Statistisk Inferens", " 4 Övningskompendium Sannolikhetslära och Inferens 4.1 Sannolikhetslära Uppgift 5 choose(n,k) räknar ut \\({n\\choose k}\\) choose(8,3) #a) ## [1] 56 choose(8,5) #b) ## [1] 56 choose(5,3)*choose(3,2) #c) ## [1] 30 Uppgift 28 Funktionen dbinom har tre argument, x,p och n och räknar ut p(x) = choose(n, x) p^x (1-p)^(n-x) det vill säga \\[p(x) = {n \\choose x} p^x(1-p)^{n-x}\\] Låt \\(X\\) vara \\(Bi(5, 0.2)\\). Bestäm \\(Pr(X = 2)\\) dbinom(x = 2, size=5, prob=0.2) ## [1] 0.2048 Låt \\(X\\) vara \\(Bi(5, 0.8)\\). Bestäm \\(Pr(X = 3)\\) dbinom(x = 3, size=5, prob=0.8) ## [1] 0.2048 Låt \\(X\\) vara \\(Bi (8, 0.4)\\). Bestäm \\(Pr(X \\le 3)\\) Nu har vi \\(\\leq\\) istället för \\(=\\), vilket gör att vi måste summera dbinom(x = 0, size=8, prob=0.4)+ dbinom(x = 1, size=8, prob=0.4)+ dbinom(x = 2, size=8, prob=0.4)+ dbinom(x = 3, size=8, prob=0.4) ## [1] 0.5940864 # Enklare: sum(dbinom(x = 0:3, size=8, prob=0.4)) ## [1] 0.5940864 Låt \\(X\\) vara \\(Bi(20, 0.3)\\). Bestäm \\(Pr(X &gt; 5)\\) 1- sum(dbinom(x = 0:5, size=20, prob=0.3)) ## [1] 0.5836292 Låt \\(X\\) vara \\(Bi (10, 0.6)\\). Bestäm \\(Pr(X \\le 5)\\) 1 - sum(dbinom(x = 0:4, size=10, prob=0.4)) ## [1] 0.3668967 Uppgift 39 Här är kod för att själv skapa en normal-kurva. Du kan ändra det skuggade området genom att ändra på lower.x och upper.x. Du kan också ändra standarddavvikelse och medelvärde genom att ändra på sigma respektive mu i funktionen skugga(). Detta är också ett exempel på hur man själv kan skapa en enkel funktion i R, men det är överkurs. skugga &lt;- function(lower.x, upper.x, mu=0, sigma=1,col=&quot;grey&quot;,density=NULL){ step &lt;- (upper.x - lower.x) / 100 bounds &lt;- c(mu-3*sigma, mu+3*sigma) cord.x &lt;- c(lower.x,seq(lower.x,upper.x,step),upper.x) cord.y &lt;- c(0,dnorm(seq(lower.x,upper.x,step),mu,sigma),0) curve(dnorm(x,mu,sigma),xlim=bounds,xlab = &quot;&quot;,ylab = &quot;&quot;,bty=&quot;n&quot;) polygon(cord.x,cord.y,col=col,density = density) } Återskapa de fyra kurvorna i uppgift 39 med skugga(lower.x = 0, upper.x = 1) # i skugga(lower.x = 1, upper.x = 2) # ii skugga(lower.x = -1, upper.x = 2) # iii skugga(lower.x = -3, upper.x = -1) # iv Dessa kurvor är väldigt bra hjälp för att förstå vad man bör göra för trix för att få fram rätt svar. I a) är vi intresserade av \\[Pr(0&lt;Z&lt;1)\\] Vi är alltså ute efter den blåa skuggade delen av Figur 4.1. skugga( -3, 1, col=&quot;red&quot;,density=10) polygon(cordx, cordy,col=&quot;lightblue&quot;, density=51) Figure 4.1: \\(Pr(0&lt;Z&lt;1)\\) Första steget är att räkna ut skuggan under hela den skuggade delen, för att sedan subtrahera den röda skuggade delen. Kvar blir bara arean under den blåa skuggade delen. det vill säga \\[Pr(0&lt;Z&lt;1) \\,=\\, Pr(Z&lt;1) \\,- \\,Pr(Z&lt;0)\\] eller pnorm(1,mean = 0, sd = 1) - pnorm(0,mean = 0,sd = 1) ## [1] 0.3413447 Faktum är att vi inte ens behöver specifiera mean=0 och sd=1 eftersom funktionen antar att du menar standard normal om inget annat anges pnorm(2) - pnorm(1) # (ii) ## [1] 0.1359051 pnorm(2) - pnorm(-1) # (iii) ## [1] 0.8185946 pnorm(-1) # (iv) ## [1] 0.1586553 Uppgift 40 Även detta är väldigt enkelt i R. Observera att om du tänkt att läsa om än bara en enda högskolepoäng mer än vad som krävs i statistik så är det lika bra att du här och nu memorerar att Z-värdet som har \\(97,5 \\%\\) av arean till vänster om sig är \\(1,96\\). Slösa aldrig dyrbar tenta-tid till att gå till Tabell 5.2.B för att hitta 1,96. Eller 1.645 heller för den delen (\\(95 \\%\\)) qnorm(0.975) ## [1] 1.959964 # Vi kan använda round() för att avrunda till önskat antal decimaler round(qnorm(0.975), digits = 2) ## [1] 1.96 round(qnorm(0.33), digits = 2) ## [1] -0.44 Uppgift 42 Vi använder oss återigen av pnorm() I och med att normalfördelningne är symmetrisk så räcker det med att vi tittar på ena sidan och multiplicerar arean med två, precis som i facit. Det vill säga, vi hittar följande area och multiplicerar med två skugga(-5,0,mu=10,sigma=4) round(pnorm(0,mean=10,sd=4)*2,4) ## [1] 0.0124 skugga(6,15,mu = 10, sigma = 4) pnorm(15,10,4)-pnorm(6,10,4) ## [1] 0.735695 4.2 Statistisk Inferens Uppgift 11 Vi har ett stickprov om 8 hissåkare, och vi kan anta att vikten i populationen är normalfördelad. Vi kan således använda formeln \\[ \\bar{x} \\pm t_{n-1,\\alpha/2}\\frac{s}{\\sqrt{n}} \\] stickprov &lt;- c(71, 85, 68, 72, 58, 76, 74, 80) xbar &lt;- mean(stickprov) # stickprovsmedelvärde n &lt;- length(stickprov) # stickprovsstorlek s = sd(stickprov) # stickprovsstandardavvikelse t = qt(0.975, df = n-1) # t-förd. med n-1 frihetsgrader xbar - t * s/sqrt(n) ## [1] 66.2376 xbar + t * s/sqrt(n) ## [1] 79.7624 Uppgift 17 \\[H_0 \\: : \\mu=9.75 \\\\ H_1 \\: : \\mu&lt;9.75\\] stickprov &lt;- c(9.0, 9.2, 9.5, 10.1, 9.8, 9.3, 9.7, 9.6, 10.0 ,9.2) t.test(stickprov, mu=9.75, # Noll-hypotesen alternative = &quot;less&quot;, # Vad för slags mothypotes har vi? conf.level = 0.95) # Vilken signifikansnivå? ## ## One Sample t-test ## ## data: stickprov ## t = -1.8156, df = 9, p-value = 0.05141 ## alternative hypothesis: true mean is less than 9.75 ## 95 percent confidence interval: ## -Inf 9.752022 ## sample estimates: ## mean of x ## 9.54 Vi ser att \\(t_{obs} = -1.8156\\) och eftersom p-värdet inte är mindre än \\(0.05\\) så kan vi ej förkasta noll-hypotesen, då vår förvalda signifikansnivå var \\(5 \\%\\). "],
["andra-paket.html", "5 Andra paket 5.1 leaflet 5.2 rtweet", " 5 Andra paket Här tänkte jag visa ett par andra paket som är lätta och roliga att använda. 5.1 leaflet med leaflet skapar vi enkelt kartor baserade på Google Maps. Observera här att i paketet leaflet finns också en funktion, leaflet(). Vi använder också paketet ggmap för att få hitta koordinater för platser, om vi inte vill gå till Google maps och hitta dem. Observera att du kommer behöva installera vissa paket, använd install.packages(&quot;paketets namn&quot;) library(ggmap) ## Loading required package: ggplot2 ggmap::geocode(&quot;ekonomikum&quot;) ## Information from URL : http://maps.googleapis.com/maps/api/geocode/json?address=ekonomikum&amp;sensor=false ## Warning: geocode failed with status OVER_QUERY_LIMIT, location = ## &quot;ekonomikum&quot; ## lon lat ## 1 NA NA library(leaflet) m &lt;- leaflet() # Funktionen leaflet m &lt;- addTiles(m) m &lt;- addMarkers(m, lng=17.61982, lat=59.85945, popup=&quot;Ekonomikum&quot;) m 5.2 rtweet med rtweet laddar vi ner data på tweets från valfria hashtags eller användare. Vi får användarens profil, följare, antal retweets och mycket mer. install.packages(&quot;rtweet&quot;) library(rtweet) tweets &lt;- search_tweets(&quot;#svpol&quot;, n = 10, include_rts = FALSE) ## Searching for tweets... ## Finished collecting tweets! tweets$text[1] ## [1] &quot;#svpol #eupol #uspol #StockholmGenderForum #Gräv18 #UnitedNations Ping @amihedenborg @deeped @jamilaraqib @AMKlasing @Kvinna_t_Kvinna @BillFrelick @AnnaLindenfors @sunderland_jude @AEDH_EU @RunMargaux @RSF_RUG @gebauerspon @schultchristoph @leclercjm https://t.co/zSQFp8fJNG&quot; tweets$profile_image_url[1] ## [1] &quot;http://pbs.twimg.com/profile_images/818767347188174848/ie0RZisv_normal.jpg&quot; "]
]
