[
["index.html", "Lösningar i R till vissa uppgifter från övningskompendierna (samt lite annat kul) 1 Introduktion 1.1 Motivering 1.2 Varför R?", " Lösningar i R till vissa uppgifter från övningskompendierna (samt lite annat kul) Erik Stenberg 2018-04-26 1 Introduktion 1.1 Motivering Detta dokument är till för dig som läser kursen Statistik A4/A8 och är nyfiken på R. Innehållet är tänkt att förena lite nytta (lösa uppgifter) med nöje (lära dig lite R). Det är inte meningen att detta dokument skall fungera som en heltäckande introduktion till programmeringsspråket R. Det finns mängder av väldigt välskrivna guider online som fokuserar mycket mer på hur språket är uppbygt. Lyckligtvis är R väldigt enkelt att komma igång med, och det krävs inte mycket förståelse för själva språket för att göra enkla beräkningar, skattningar av modeller, rita grafer och göra hypotestester. R är programmeringsspråket vi kommer använda, och vi kommer göra allt arbete i RStudio, som är en IDE (Integrated Developer Environment) för R. RStudio gör arbete med R mycket enklare. Du behöver både R och RStudio på din egen dator, eller använda någon av datorerna i labben. Här är en bra början för att lära dig syntaxen i R utan att behöva installera varker R eller RStudio. Om du har installerat R och RStudio, så är swirl ett ganska roligt sätt att lära sig. 1.2 Varför R? R är gratis, populärt och enkelt att komma igång med. Under det senaste årtiondet har populariteten växt enormt och i dag är R ett av de absolut mest använda verktygen för data-analys, både ute i verkligheten och inom forskningsvärlden. Om du någon gång tänkt skriva en uppsats i statistik, företagsekonomi nationalekonomi, eller någonting kvantitativt i vilket ämne som helst, kan R vara en bra vän att ha. library(fortunes) fortune(&#39;subway&#39;) ## ## Soon, they&#39;ll be speaking R on the subway. ## -- Michael Rennie (giving &#39;Kudos to the R support team&#39;) ## R-help (July 2004) "],
["kom-igang.html", "2 Kom igång 2.1 Viktiga funktioner 2.2 Funktioner och paket", " 2 Kom igång 2.1 Viktiga funktioner Jag förutsätter att du har R och RStudio installerat (eller sitter vid någon av datorerna statistik-labbarna). Som tidigare nämnts så kommer detta inte vara någon genomgående guide till R, men det finns ett par saker som är viktiga att nämna innan vi kör igång. Skriver du 1+1 så kommer R ge dig 2. 1+1 ## [1] 2 Du kan också skapa ett objekt med &lt;- som kallas the assign operator. x &lt;- 1+1 Notera att R inte kommer skriva ut vad x är förrän du ber om det x ## [1] 2 I detta dokument kommer resultat från R alltid föregås av ##. Det är så du kan se skillnad på vad jag skriver och vad R ger tillbaka. Ibland kommer du även se enskilda # i koden. Allting som skrivs efter # behandlas av R som icke-kod. Det vill säga, jag kommer ofta använda # kommentar i koden för att förtydliga någonting jag gör. Vektorer är den absolut vanligaste datatypen i R, och du kommer vid flera tillfällen behöva skapa vektorer. Ofta skapar vi vektorer med funktionen c(). För att se om ett objekt är en vektor använder du med framgång is.vector. x &lt;- c(1,5,7,2,4,6,7) # jag skapar en vektor och kallar den x is.vector(x) # jag frågar R om x är en vektor ## [1] TRUE I detta fallet är x alltså en numerisk vektor, men det finns olika sorters vektorer. y &lt;- c(&quot;R&quot;,&quot;är&quot;,&quot;kul&quot;) is.vector(y) ## [1] TRUE is.numeric(y) ## [1] FALSE is.character(y) ## [1] TRUE y är alltså en character vector. Dessa objekt kommer i vårt fall ofta vara stickprov. Låt säga att vi har frågat några personer om deras längd. stickprov &lt;- c(170, 165, 151, 191, 180, 172, 181, 166, 155, 194, 166, 175, 144, 188, 192, 164, 178, 201) Vi kan enkelt hitta stickprovsstorlek, medelvärde, standardavvikelse och skapa ett histogram length(stickprov) # längd (stickprovsstorlek) ## [1] 18 mean(stickprov) # medelvärde ## [1] 174.0556 sd(stickprov) # standardavvikelse ## [1] 15.64109 hist(stickprov) Låt säga att jag har två vektorer, en med namn på universitet och en med antal studenter (enligt wikipedia). namn &lt;- c(&quot;UU&quot;, &quot;KTH&quot;, &quot;SU&quot;, &quot;LU&quot;) studenter &lt;- c(24623, 12000, 29087, 40000) Om jag istället för att ha två separata objekt, namn och studenter bara vill ha ett objekt. Då skapar jag med fördel en såkallad data frame, med funktionen cbind.data.frame() z &lt;- cbind.data.frame(namn,studenter) is.vector(z) # z är inte längre en vektor ## [1] FALSE is.data.frame(z) # z är en data frame ## [1] TRUE Så hur ser z ut? z ## namn studenter ## 1 UU 24623 ## 2 KTH 12000 ## 3 SU 29087 ## 4 LU 40000 För att “komma åt” data från en data frame kan jag använda $. z$studenter ## [1] 24623 12000 29087 40000 Eftersom z$studenter är en numerisk vektor kan jag göra precis samma sak på z$studenter som jag kunde göra på stickprovet ovan. mean(z$studenter) ## [1] 26427.5 sd(z$studenter) ## [1] 11585.83 Skulle jag försöka göra samma sak på z$namn får jag en varning och resultatet blir NA. Jag kan naturligtvis inte räkna ut medelvärdet av fyra namn. mean(z$namn) ## Warning in mean.default(z$namn): argument is not numeric or logical: ## returning NA ## [1] NA 2.2 Funktioner och paket gapminder En sak som är bra med RStudio är att det finns väldigt bra dokumentation utan att du behöver gå till din webbläsare och söka. Om du undrar hur en funktion fungerar så räcker det ofta med att skriva ett frågetecken följt av funktionens namn, ex: ?mean, och en hjälp-sida visas i din “viewer pane” till höger. Längst ner på hjälp-sidan finns ofta enkla exempel. Många funktioner i R kommer från externa paket. Vissa av dem är otroligt enkla att använda, andra tar lång tid att lära sig. Vem som helst kan skriva ett paket, och de är enkla att installera. Det finns otroligt många paket, och användningsområdena är nästan lika många. För att demonstrera hur installationen av ett paket går till kan vi titta på ett paket som heter gapminder, som innehåller data tillänglig på Gapminder.org. Första gången du använder ett paket behöver du installera det. Det gör du genom att skriva install.packages(&quot;gapminder&quot;) Observera citationstecken. Detta behöver du bara göra en gång på din dator. När du vill använda paketet i framtiden måste du, varje gång du öppnar RStudio, skriva library(gapminder) Paketet gapminder är ett litet paket och innehåller inga funktioner, bara dataset. Ett av dataseten heter gapminder och innehåller data på bland annat förväntad linvslängd, population, BNP etc. Du laddar ner datan genom att helt enkelt skriva gapminder ## # A tibble: 1,704 x 6 ## country continent year lifeExp pop gdpPercap ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Afghanistan Asia 1952 28.8 8425333 779. ## 2 Afghanistan Asia 1957 30.3 9240934 821. ## 3 Afghanistan Asia 1962 32.0 10267083 853. ## 4 Afghanistan Asia 1967 34.0 11537966 836. ## 5 Afghanistan Asia 1972 36.1 13079460 740. ## 6 Afghanistan Asia 1977 38.4 14880372 786. ## 7 Afghanistan Asia 1982 39.9 12881816 978. ## 8 Afghanistan Asia 1987 40.8 13867957 852. ## 9 Afghanistan Asia 1992 41.7 16317921 649. ## 10 Afghanistan Asia 1997 41.8 22227415 635. ## # ... with 1,694 more rows Du behöver inte bry dig om texten A tibble: 1,704 x 6. En tibble är bara en sorts data frame. Vi kan försäkra oss om detta genom att kolla så att gm nedan is.data.frame() is.data.frame(gapminder) ## [1] TRUE Det vill säga, det är fritt fram att göra alla sorters beräkningar på detta data set precis som vi gjorde på vår data frame med studenter och universitet ovan. Faktum är i sektion 5.4 har visar jag lite olika funktioner, grafer och beräkningar du kan göra på just detta data set. stats Ett annat paket som, likt de flesta andra paket, faktiskt innehåller flera funktioner är stats som innehåller funktioner för statistiska beräkningar med mera. Här är ett par exempel funktioner. stats är förinstallerat och igång vid uppstart, så du behöver varken installera det med install.packages(&quot;stats&quot;) eller skriva library(stats). Ett exempel på funktioner i stats är rnorm() som genererar slumpmässiga tal från normalfördelningen. rnorm(n = 5, mean = 0, sd = 1) # Ger oss fem slumpmässiga nummer från N(0,1) ## [1] -0.56047565 -0.23017749 1.55870831 0.07050839 0.12928774 n, mean och sd är stickprovsstorlek, medelvärde och standardavvikelse respektive. De kallas argument. Funktionen rnorm() har bara dessa tre argument, och de behöver inte skrivas ut. Det vill säga, så länge du håller koll på i vilken ordning argumenten kommer så kan du lika gärna skriva rnorm(5,0,1) # Samma resultat (men så klart nya tal) ## [1] -1.2070657 0.2774292 1.0844412 -2.3456977 0.4291247 Ofta har funktionernas argument ett “default” värde. Det vill säga, ett värde på argumentet om du inte själv specifierar det. I fallet rnorm() kan du säkert gissa dig till vilket medelvärde och vilken standardavvikelse som är default, nämligen mean=0 och sd=1, det vill säga Z-fördelningen. Stickprovsstorlek har däremot inget default, och måste specifieras manuellt. rnorm(5) ## [1] 0.5060559 -0.5747400 -0.5466319 -0.5644520 -0.8900378 Låt oss ta ett större stickprov, spara resultatet som x och skapa ett histogram, med funktionen hist(). x &lt;- rnorm(100000) hist(x) Lek runt lite med de olika argumenten. För en full lista med alla argument, titta på hjälpsidan genom ?hist hist(x, breaks = 100, col = &quot;pink&quot;, ylab = &quot;text på y-axeln&quot;, xlab = &quot;text på x-axeln&quot;, main = &quot;Stickprov om 100,000 från N(0,1)&quot;) En annan funktion vi kommer använda är pnorm(). pnorm() ger dig arean under en normalfördelningskurva för en given normalfördelning. Säg till exempel att vi har en normalfördelning med medelvärde 0 och standardavvikelse 1, det vill säga \\(N(0,1)\\). Med pnorm() kan du då hitta \\(Pr(Z\\leq z)\\), det vill säga, sannolikheten att ett slumpmässigt valt tal från Z-fördelningen är mindre eller lika med \\(z\\). För \\(z=0\\) skriver du pnorm(0, mean = 0 , sd=1) ## [1] 0.5 vilket är samma som den skuggade delen nedan Du kan såklart även hitta arean mellan två punkter genom att subtrahera, precis som du gör när du hittar \\(Pr(0\\leq Z \\leq 1)\\) för hand. pnorm(1, mean = 0 , sd=1) - pnorm(0, mean = 0 , sd=1) ## [1] 0.3413447 Vilket motsvara arean Faktum är att Tabell 5.2A i formelsamlingen kan återskapas genom att kalla funktionen pnorm() på varje tal i sekvensen \\(0, 0.01, 0.02, 0.03, ... , 3.59\\). För at helt återskapa Tabell 5.2A så måste vi också avrunda varje sannolikhet till 4 decimaler med round(). round(pnorm(seq(0,3.59,by=0.01),mean = 0,sd = 1),4) ## [1] 0.5000 0.5040 0.5080 0.5120 0.5160 0.5199 0.5239 0.5279 0.5319 0.5359 ## [11] 0.5398 0.5438 0.5478 0.5517 0.5557 0.5596 0.5636 0.5675 0.5714 0.5753 ## [21] 0.5793 0.5832 0.5871 0.5910 0.5948 0.5987 0.6026 0.6064 0.6103 0.6141 ## [31] 0.6179 0.6217 0.6255 0.6293 0.6331 0.6368 0.6406 0.6443 0.6480 0.6517 ## [41] 0.6554 0.6591 0.6628 0.6664 0.6700 0.6736 0.6772 0.6808 0.6844 0.6879 ## [51] 0.6915 0.6950 0.6985 0.7019 0.7054 0.7088 0.7123 0.7157 0.7190 0.7224 ## [61] 0.7257 0.7291 0.7324 0.7357 0.7389 0.7422 0.7454 0.7486 0.7517 0.7549 ## [71] 0.7580 0.7611 0.7642 0.7673 0.7704 0.7734 0.7764 0.7794 0.7823 0.7852 ## [81] 0.7881 0.7910 0.7939 0.7967 0.7995 0.8023 0.8051 0.8078 0.8106 0.8133 ## [91] 0.8159 0.8186 0.8212 0.8238 0.8264 0.8289 0.8315 0.8340 0.8365 0.8389 ## [101] 0.8413 0.8438 0.8461 0.8485 0.8508 0.8531 0.8554 0.8577 0.8599 0.8621 ## [111] 0.8643 0.8665 0.8686 0.8708 0.8729 0.8749 0.8770 0.8790 0.8810 0.8830 ## [121] 0.8849 0.8869 0.8888 0.8907 0.8925 0.8944 0.8962 0.8980 0.8997 0.9015 ## [131] 0.9032 0.9049 0.9066 0.9082 0.9099 0.9115 0.9131 0.9147 0.9162 0.9177 ## [141] 0.9192 0.9207 0.9222 0.9236 0.9251 0.9265 0.9279 0.9292 0.9306 0.9319 ## [151] 0.9332 0.9345 0.9357 0.9370 0.9382 0.9394 0.9406 0.9418 0.9429 0.9441 ## [161] 0.9452 0.9463 0.9474 0.9484 0.9495 0.9505 0.9515 0.9525 0.9535 0.9545 ## [171] 0.9554 0.9564 0.9573 0.9582 0.9591 0.9599 0.9608 0.9616 0.9625 0.9633 ## [181] 0.9641 0.9649 0.9656 0.9664 0.9671 0.9678 0.9686 0.9693 0.9699 0.9706 ## [191] 0.9713 0.9719 0.9726 0.9732 0.9738 0.9744 0.9750 0.9756 0.9761 0.9767 ## [201] 0.9772 0.9778 0.9783 0.9788 0.9793 0.9798 0.9803 0.9808 0.9812 0.9817 ## [211] 0.9821 0.9826 0.9830 0.9834 0.9838 0.9842 0.9846 0.9850 0.9854 0.9857 ## [221] 0.9861 0.9864 0.9868 0.9871 0.9875 0.9878 0.9881 0.9884 0.9887 0.9890 ## [231] 0.9893 0.9896 0.9898 0.9901 0.9904 0.9906 0.9909 0.9911 0.9913 0.9916 ## [241] 0.9918 0.9920 0.9922 0.9925 0.9927 0.9929 0.9931 0.9932 0.9934 0.9936 ## [251] 0.9938 0.9940 0.9941 0.9943 0.9945 0.9946 0.9948 0.9949 0.9951 0.9952 ## [261] 0.9953 0.9955 0.9956 0.9957 0.9959 0.9960 0.9961 0.9962 0.9963 0.9964 ## [271] 0.9965 0.9966 0.9967 0.9968 0.9969 0.9970 0.9971 0.9972 0.9973 0.9974 ## [281] 0.9974 0.9975 0.9976 0.9977 0.9977 0.9978 0.9979 0.9979 0.9980 0.9981 ## [291] 0.9981 0.9982 0.9982 0.9983 0.9984 0.9984 0.9985 0.9985 0.9986 0.9986 ## [301] 0.9987 0.9987 0.9987 0.9988 0.9988 0.9989 0.9989 0.9989 0.9990 0.9990 ## [311] 0.9990 0.9991 0.9991 0.9991 0.9992 0.9992 0.9992 0.9992 0.9993 0.9993 ## [321] 0.9993 0.9993 0.9994 0.9994 0.9994 0.9994 0.9994 0.9995 0.9995 0.9995 ## [331] 0.9995 0.9995 0.9995 0.9996 0.9996 0.9996 0.9996 0.9996 0.9996 0.9997 ## [341] 0.9997 0.9997 0.9997 0.9997 0.9997 0.9997 0.9997 0.9997 0.9997 0.9998 ## [351] 0.9998 0.9998 0.9998 0.9998 0.9998 0.9998 0.9998 0.9998 0.9998 0.9998 Motsvarande funktion för att hitta vilket z-värde som representerar en given sannolikhet (Tabell 5.2B) är funktionen qnorm(). Tabell 5.2B ger dig vilket z-värde som har \\(P\\) procent till höger om sig, medan qnorm() ger dig vilket z-värde som har \\(P\\) procent till vänster om sig. Så om vi skriver -qnorm() får vi samma resultat som tabellen i formelsamligen. Det vill säga -qnorm(0.025, mean = 0, sd = 1) ## [1] 1.959964 Vilket motsvara följande area under Z-fördelningen. Det vill säga, sannolikheten \\(2.5 \\%\\) är associerat med z-värdet \\(1.959964 \\approx 1.96\\) "],
["ovningskompendium-deskriptiv-statistik.html", "3 Övningskompendium Deskriptiv Statistik 3.1 Deskription 3.2 Spridningsdiagram och Korrelation 3.3 Tidsserier", " 3 Övningskompendium Deskriptiv Statistik 3.1 Deskription Uppgift 16 betyg &lt;- c(1, 4, 4, 3, 2, 3, 3, 3, 5, 2, 3, 3, 3, 2, 4, 4, 3, 1, 2, 5, 3, 3, 4, 2, 3, 4, 2, 3) mean(betyg) ## [1] 3 median(betyg) ## [1] 3 Det finns faktiskt ingen inbyggd funktion i R för typ-värde(!), men vi kan använda table() för att hitta vad vi söker. 3 förekommer 12 gånger. table(betyg) ## betyg ## 1 2 3 4 5 ## 2 6 12 6 2 x &lt;- table(betyg) barplot(x) Uppigift 17 husdjur &lt;- c(rep(0,20), rep(1,15), rep(2,10), rep(3,5)) mean(husdjur) ## [1] 1 median(husdjur) ## [1] 1 x &lt;- table(husdjur) plot(cumsum(x), # cumsum för cumulative sum type = &quot;S&quot;, # &quot;S&quot; för &quot;steps&quot; xlim = c(0,4), # Undre och övre gräns för x ylim = c(0,50), # Undre och övre gräns för y xlab = &quot;Antal Husdjur&quot; , # Text på x-axeln ylab = &quot;Summa Antal Familjer&quot;) # Text på y-axeln segments(x0 = 0, y0 = 0, x1 = 0, y1 = 20) segments(x0 = 0, y0 = 20, x1 = 1, y1 = 20) segments(x0 = 0, y0 = 25,x1 = 1, y1 = 25,col = &quot;red&quot;,lwd=2,lty = 6) arrows(x0 = 1,y0 = 25,x1 = 1,y1 = 0, col = &quot;red&quot;,lwd=2, lty = 6) Uppgift 18 löner &lt;- c(341000, 193000, 167000, 167000, 156000, 154000, 148000, 148000, 148000, 148000) mean(löner) ## [1] 177000 median(löner) ## [1] 155000 table(löner) ## löner ## 148000 154000 156000 167000 193000 341000 ## 4 1 1 2 1 1 barplot(table(löner)) # Sned fördelning -&gt; använd median Uppgift 21 Vi har följande tabell Antal Olycksfall per dag Frekvens 0 21 1 18 3 10 4 1 Givetvis kan vi skapa vektorn och använda mean()och sd() tabell &lt;- c(rep(0,21),rep(1,18),rep(2,7),rep(3,3),rep(4,1)) mean(tabell) ## [1] 0.9 var(tabell) ## [1] 0.9897959 Men säg att vi hade fått en stor dataframe, och det hade varit för mycket jobb för att skriva en massa rep(). Det vill säga, säg att någon gav oss df nedan df &lt;- as.data.frame(cbind(c(0,1,2,3,4),c(21,18,7,3,1))) colnames(df) &lt;- c(&quot;olycksfall&quot;, &quot;frekvens&quot;) df ## olycksfall frekvens ## 1 0 21 ## 2 1 18 ## 3 2 7 ## 4 3 3 ## 5 4 1 Istället för att återskapa tabell ovan (som förvisso är väldigt enkelt - bara använd table()), så kan vi gå den långa vägen och använda. \\[\\bar{x} = \\frac{\\sum{f_i x_i}}{n}\\] \\[s^2 = \\frac{\\sum{f_i x_i^2}-\\frac{\\sum{(f_i x_i)}^2}{n}}{n-1}\\] n &lt;- sum(df$frekvens) f = df$frekvens x = df$olycksfall medelvärde = sum(f*x)/n varians = (sum(f*x^2) - sum((f*x))^2/n) / (n-1) medelvärde ## [1] 0.9 varians ## [1] 0.9897959 3.2 Spridningsdiagram och Korrelation Uppgift 101 x &lt;- as.data.frame(cbind(c(5500,6000,6500,6000,5000,6500,4500,5000), c(41,38,35,40,44,38,45,42))) colnames(x) &lt;- c(&quot;Pris&quot;,&quot;Försäljning&quot;) Vilket ger oss följande dataframe head(x) ## Pris Försäljning ## 1 5500 41 ## 2 6000 38 ## 3 6500 35 ## 4 6000 40 ## 5 5000 44 ## 6 6500 38 Korrelationsmatris cor(x) ## Pris Försäljning ## Pris 1.0000000 -0.9426412 ## Försäljning -0.9426412 1.0000000 Notera att vi egentligen inte behöver skriva type=&quot;p&quot; i plot() nedan, eftersom detta är default när man använder funktionen på objekt som x. plot(x, type= &quot;p&quot; , xlab = &quot;Pris (kr)&quot;, ylab = &quot;Försäljning (antal)&quot;, pch=16) # För at få prickarna ifyllda Gör precis samma sak för uppgift 102 Uppgift 105 dat &lt;- cbind.data.frame(1:12, c(3,4,6,2,5,6,5,4,7,6,5,4), c(14,23,25,17,30,44,35,34,39,32,38,29), c(23,30,29,26,35,58,30,50,55,45,44,34)) colnames(dat) &lt;- c(&quot;person&quot;,&quot;X&quot;,&quot;Y&quot;,&quot;Z&quot;) Z &lt;- dat$Z Y &lt;- dat$Y Såhär ser vår dataframe ut head(dat) ## person X Y Z ## 1 1 3 14 23 ## 2 2 4 23 30 ## 3 3 6 25 29 ## 4 4 2 17 26 ## 5 5 5 30 35 ## 6 6 6 44 58 Korrelationsmatris igen cor(dat) ## person X Y Z ## person 1.0000000 0.3634301 0.6489737 0.5587045 ## X 0.3634301 1.0000000 0.7407156 0.6456707 ## Y 0.6489737 0.7407156 1.0000000 0.8650861 ## Z 0.5587045 0.6456707 0.8650861 1.0000000 Vi ser att Y verkar ha högst korrelation med X, ungefär \\(0.74\\). Linjär regression i R är enkelt. I funktionen lm() anger du vilken data du vill använda, i vårt fall data = dat, formulan skrivs på formen formula = y~z. Ett intercept skattas per default, men kan undvikas genom att skriva -1 i formulan, i.e y~x-1. lm(Y ~ Z, dat) ## ## Call: ## lm(formula = Y ~ Z, data = dat) ## ## Coefficients: ## (Intercept) Z ## 4.7390 0.6604 plot(Z, Y, pch=16) abline(lm(Y ~ Z, dat), col=&quot;red&quot;) Uppgift 107 Förbered data res &lt;- cbind.data.frame(c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;), c(11.2, 11.4, 10.8, 10.9, 11.0 , 11.3), c(676, 660, 685, 670, 690, 669)) colnames(res) &lt;- c(&quot;pers&quot;,&quot;löp&quot;,&quot;hopp&quot;) Beräkningar cor(res$löp,res$hopp) ## [1] -0.695163 summary(res$löp) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 10.80 10.93 11.10 11.10 11.28 11.40 summary(res$hopp) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 660.0 669.2 673.0 675.0 682.8 690.0 y &lt;- res$löp x &lt;- res$hopp plot(x,y, xlim = c(650,700), ylim = c(10,12), pch = 16, ylab = &quot;Löp (sek)&quot;, xlab = &quot;Hopp (cm)&quot;) 3.3 Tidsserier Uppgift 401 y &lt;-c(0.175, 0.249, 0.279, 0.376, 0.528, 0.781, 1.123, 1.681, 3.131) t &lt;- 1970:1978 - 1974 lm(y~t) ## ## Call: ## lm(formula = y ~ t) ## ## Coefficients: ## (Intercept) t ## 0.9248 0.3035 Uppgift 402 y &lt;-c(0.175, 0.249, 0.279, 0.376, 0.528, 0.781, 1.123, 1.681, 3.131) y &lt;- ts(y, start = 1970, end = 1978, frequency = 1) plot.ts(y) Vi försöker igen med en expoentiell trend. y_prime = log(y,base = 10) lm(y_prime~t) ## ## Call: ## lm(formula = y_prime ~ t) ## ## Coefficients: ## (Intercept) t ## -0.2170 0.1504 För att få tillbaka vårt önskade resulat (se lösningarna för detaljer) så löser vi m &lt;- lm(y_prime~t) 10^m$coefficients ## (Intercept) t ## 0.6067278 1.4139314 "],
["ovningskompendium-sannolikhetslara-och-inferens.html", "4 Övningskompendium Sannolikhetslära och Inferens 4.1 Sannolikhetslära 4.2 Statistisk Inferens", " 4 Övningskompendium Sannolikhetslära och Inferens 4.1 Sannolikhetslära Uppgift 5 choose(n,k) räknar ut \\({n\\choose k}\\) choose(8,3) #a) ## [1] 56 choose(8,5) #b) ## [1] 56 choose(5,3)*choose(3,2) #c) ## [1] 30 Uppgift 28 Funktionen dbinom har tre argument, x,p och n och räknar ut p(x) = choose(n, x) p^x (1-p)^(n-x) det vill säga \\[p(x) = {n \\choose x} p^x(1-p)^{n-x}\\] Låt \\(X\\) vara \\(Bi(5, 0.2)\\). Bestäm \\(Pr(X = 2)\\) dbinom(x = 2, size=5, prob=0.2) ## [1] 0.2048 Låt \\(X\\) vara \\(Bi(5, 0.8)\\). Bestäm \\(Pr(X = 3)\\) dbinom(x = 3, size=5, prob=0.8) ## [1] 0.2048 Låt \\(X\\) vara \\(Bi (8, 0.4)\\). Bestäm \\(Pr(X \\le 3)\\) Nu har vi \\(\\leq\\) istället för \\(=\\), vilket gör att vi måste summera dbinom(x = 0, size=8, prob=0.4)+ dbinom(x = 1, size=8, prob=0.4)+ dbinom(x = 2, size=8, prob=0.4)+ dbinom(x = 3, size=8, prob=0.4) ## [1] 0.5940864 # Enklare: sum(dbinom(x = 0:3, size=8, prob=0.4)) ## [1] 0.5940864 Låt \\(X\\) vara \\(Bi(20, 0.3)\\). Bestäm \\(Pr(X &gt; 5)\\) 1- sum(dbinom(x = 0:5, size=20, prob=0.3)) ## [1] 0.5836292 Låt \\(X\\) vara \\(Bi (10, 0.6)\\). Bestäm \\(Pr(X \\le 5)\\) 1 - sum(dbinom(x = 0:4, size=10, prob=0.4)) ## [1] 0.3668967 Uppgift 39 Här är kod för att själv skapa en normal-kurva. Du kan ändra det skuggade området genom att ändra på lower.x och upper.x. Du kan också ändra standarddavvikelse och medelvärde genom att ändra på sigma respektive mu i funktionen skugga(). Detta är också ett exempel på hur man själv kan skapa en enkel funktion i R, men det är överkurs. skugga &lt;- function(lower.x, upper.x, mu=0, sigma=1,col=&quot;grey&quot;,density=NULL){ step &lt;- (upper.x - lower.x) / 100 bounds &lt;- c(mu-3*sigma, mu+3*sigma) cord.x &lt;- c(lower.x,seq(lower.x,upper.x,step),upper.x) cord.y &lt;- c(0,dnorm(seq(lower.x,upper.x,step),mu,sigma),0) curve(dnorm(x,mu,sigma),xlim=bounds,xlab = &quot;&quot;,ylab = &quot;&quot;,bty=&quot;n&quot;) polygon(cord.x,cord.y,col=col,density = density) } Återskapa de fyra kurvorna i uppgift 39 med skugga(lower.x = 0, upper.x = 1) # i skugga(lower.x = 1, upper.x = 2) # ii skugga(lower.x = -1, upper.x = 2) # iii skugga(lower.x = -3, upper.x = -1) # iv Dessa kurvor är väldigt bra hjälp för att förstå vad man bör göra för trix för att få fram rätt svar. I a) är vi intresserade av \\[Pr(0&lt;Z&lt;1)\\] Vi är alltså ute efter den blåa skuggade delen av Figur 4.1. Figure 4.1: \\(Pr(0&lt;Z&lt;1)\\) Första steget är att räkna ut skuggan under hela den skuggade delen, för att sedan subtrahera den röda skuggade delen. Kvar blir bara arean under den blåa skuggade delen. det vill säga \\[Pr(0&lt;Z&lt;1) \\,=\\, Pr(Z&lt;1) \\,- \\,Pr(Z&lt;0)\\] eller pnorm(1,mean = 0, sd = 1) - pnorm(0,mean = 0,sd = 1) ## [1] 0.3413447 Faktum är att vi inte ens behöver specifiera mean=0 och sd=1 eftersom funktionen antar att du menar standard normal om inget annat anges pnorm(2) - pnorm(1) # (ii) ## [1] 0.1359051 pnorm(2) - pnorm(-1) # (iii) ## [1] 0.8185946 pnorm(-1) # (iv) ## [1] 0.1586553 Uppgift 40 Även detta är väldigt enkelt i R. Observera att om du tänkt att läsa om än bara en enda högskolepoäng mer än vad som krävs i statistik så är det lika bra att du här och nu memorerar att Z-värdet som har \\(97,5 \\%\\) av arean till vänster om sig är \\(1,96\\). Slösa aldrig dyrbar tenta-tid till att gå till Tabell 5.2.B för att hitta 1,96. Eller 1.645 heller för den delen (\\(95 \\%\\)) qnorm(0.975) ## [1] 1.959964 # Vi kan använda round() för att avrunda till önskat antal decimaler round(qnorm(0.975), digits = 2) ## [1] 1.96 round(qnorm(0.33), digits = 2) ## [1] -0.44 Uppgift 42 Vi använder oss återigen av pnorm() I och med att normalfördelningne är symmetrisk så räcker det med att vi tittar på ena sidan och multiplicerar arean med två, precis som i facit. Det vill säga, vi hittar följande area och multiplicerar med två skugga(-5,0,mu=10,sigma=4) round(pnorm(0,mean=10,sd=4)*2,4) ## [1] 0.0124 skugga(6,15,mu = 10, sigma = 4) pnorm(15,10,4)-pnorm(6,10,4) ## [1] 0.735695 4.2 Statistisk Inferens Uppgift 11 Vi har ett stickprov om 8 hissåkare, och vi kan anta att vikten i populationen är normalfördelad. Vi kan således använda formeln \\[ \\bar{x} \\pm t_{n-1,\\alpha/2}\\frac{s}{\\sqrt{n}} \\] stickprov &lt;- c(71, 85, 68, 72, 58, 76, 74, 80) xbar &lt;- mean(stickprov) # stickprovsmedelvärde n &lt;- length(stickprov) # stickprovsstorlek s = sd(stickprov) # stickprovsstandardavvikelse t = qt(0.975, df = n-1) # t-förd. med n-1 frihetsgrader xbar - t * s/sqrt(n) ## [1] 66.2376 xbar + t * s/sqrt(n) ## [1] 79.7624 Uppgift 17 \\[H_0 \\: : \\mu=9.75 \\\\ H_1 \\: : \\mu&lt;9.75\\] stickprov &lt;- c(9.0, 9.2, 9.5, 10.1, 9.8, 9.3, 9.7, 9.6, 10.0 ,9.2) t.test(stickprov, mu=9.75, # Noll-hypotesen alternative = &quot;less&quot;, # Vad för slags mothypotes har vi? conf.level = 0.95) # Vilken signifikansnivå? ## ## One Sample t-test ## ## data: stickprov ## t = -1.8156, df = 9, p-value = 0.05141 ## alternative hypothesis: true mean is less than 9.75 ## 95 percent confidence interval: ## -Inf 9.752022 ## sample estimates: ## mean of x ## 9.54 Vi ser att \\(t_{obs} = -1.8156\\) och eftersom p-värdet inte är mindre än \\(0.05\\) så kan vi ej förkasta noll-hypotesen, då vår förvalda signifikansnivå var \\(5 \\%\\). "],
["andra-paket.html", "5 Andra paket 5.1 leaflet 5.2 rtweet 5.3 quantmod 5.4 dplyr", " 5 Andra paket Här är en kort introduktion till ett par andra paket som är lätta och roliga att använda. 5.1 leaflet med leaflet skapar vi enkelt kartor baserade på Google Maps. Observera här att i paketet leaflet finns också en funktion, leaflet(). Vi använder också paketet ggmap för att få hitta koordinater för platser, om vi inte vill gå till Google maps och hitta dem. Observera att du kommer behöva installera vissa paket, använd install.packages(&quot;paketets namn&quot;) library(ggmap) ## Loading required package: ggplot2 ggmap::geocode(&quot;ekonomikum&quot;) ## Information from URL : http://maps.googleapis.com/maps/api/geocode/json?address=ekonomikum&amp;sensor=false ## lon lat ## 1 17.61982 59.85945 library(leaflet) m &lt;- leaflet() # Funktionen leaflet m &lt;- addTiles(m) m &lt;- addMarkers(m, lng=17.61982, lat=59.85945, popup=&quot;Ekonomikum&quot;) m 5.2 rtweet med rtweet laddar vi ner data på tweets från valfria hashtags eller användare. Vi får användarens profil, följare, antal retweets och mycket mer. library(rtweet) tweets &lt;- search_tweets(&quot;#svpol&quot;, n = 10, include_rts = FALSE) ## Searching for tweets... ## Finished collecting tweets! tweets$text[1] ## [1] &quot;Sveriges nya statsminister heter Lina Hultqvist (@Lina_Hultqvist). \\n\\nLina är ordförande för @SveElevkarer och jobbar nu hårt inför Skolval2018. Mycket fokus på skolan, landsbygd och en hel del försvarspolitik. \\n\\nLyssna här: https://t.co/5kkxc59DJc\\n\\n #svpol #skolval2018 #val2018&quot; tweets$profile_image_url[1] ## [1] &quot;http://pbs.twimg.com/profile_images/831139426826850304/huzY0Zx9_normal.jpg&quot; 5.3 quantmod Paket-författarna själva beskriver quantmod som ett “Quantitative Financial Modelling and Trading Framework for R”. Det finns en mängd funktioner, med här demonstrerar jag hur du kan ladda ner data från enskilda aktier eller börsindex. Du behöver registrera dig på tiingo.com för att få en API-nyckel. Efter registrering, logga in och gå till API&gt;Documentation&gt;2.2.1 Daily Prices En bit ner på sidan hittar du din API-nyckel key &lt;- &quot;...............&quot; # Byt ut .... mot din nyckel Vi kan exempelvis ladda ner data Facebooks aktie, använd funktionen getSymbols(), argumentet src är varifrån vi hämtar data, api.key är helt enkelt din API-nyckel. Data kommer sparas som ett objekt FB. library(quantmod) getSymbols(&quot;FB&quot;, src = &quot;tiingo&quot;,api.key = key) ## [1] &quot;FB&quot; ?getSymbols Vi kan inspektera de fem senaste dagarna med tail()… tail(FB, 5) ## FB.Open FB.High FB.Low FB.Close FB.Volume ## 2018-04-19 166.2000 168.33 165.20 168.10 22234961 ## 2018-04-20 167.7900 168.43 165.81 166.28 19119438 ## 2018-04-23 167.2700 168.45 165.09 165.84 23088102 ## 2018-04-24 165.4300 166.10 158.19 159.69 35079926 ## 2018-04-25 160.1448 161.06 156.19 159.69 41083581 …och skapa en tidsserieplot med plot() plot(FB$FB.Close,col=&quot;black&quot;) Det är mycket som pågår under the hood här. Till exempel: hur vet funktionen plot() vad för sorts graf den ska rita, och var den ska leta efter tiden (som visas på x-axeln)? Går man in på djupet blir det snabbt väldigt komplicerat, och vi lämnar såldes denna diskussion tills vidare. 5.4 dplyr Här kommer jag introducera paketet dplyr som är ett fantastiskt intuitivt sätt att manipulera data. Först måste du i vanlig ordning installera paketet med install.packages(). Glöm inte citationstecken. Sedan library(dplyr) I dplyr finns %&gt;%. Med %&gt;% (som kallas the pipe operator) behöver vi inte skriva det första argumentet i en funktion inuti själva funktionen. Det är mycket enklare att förstå med ett exempel. Notera hur dessa två funktioner (som avrundar x till en decimal) producerar samma resultat x &lt;- c(0.109, 0.359, 0.63, 0.996, 0.515, 0.142, 0.017, 0.829, 0.907) round(x,1) ## [1] 0.1 0.4 0.6 1.0 0.5 0.1 0.0 0.8 0.9 x %&gt;% round(1) ## [1] 0.1 0.4 0.6 1.0 0.5 0.1 0.0 0.8 0.9 I detta fallet går det så klart snabbare att bara skriva round(x,1), men när du applicerar många funktioner på x så skall du snart se att du kan skriva mycket mer intuitiv kod med %&gt;% round(exp(diff(log(x))), 1) ## [1] 3.3 1.8 1.6 0.5 0.3 0.1 48.8 1.1 x %&gt;% log() %&gt;% diff() %&gt;% exp() %&gt;% round(1) ## [1] 3.3 1.8 1.6 0.5 0.3 0.1 48.8 1.1 Framför allt är som sagt dplyr bra för datamanipulering. Den innehåller en rad bra funkltioner som jag demonstrerar nedan med hjälp av ett data set vi redan är bekanta med, gapminder. library(gapminder) gapminder ## # A tibble: 1,704 x 6 ## country continent year lifeExp pop gdpPercap ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Afghanistan Asia 1952 28.8 8425333 779. ## 2 Afghanistan Asia 1957 30.3 9240934 821. ## 3 Afghanistan Asia 1962 32.0 10267083 853. ## 4 Afghanistan Asia 1967 34.0 11537966 836. ## 5 Afghanistan Asia 1972 36.1 13079460 740. ## 6 Afghanistan Asia 1977 38.4 14880372 786. ## 7 Afghanistan Asia 1982 39.9 12881816 978. ## 8 Afghanistan Asia 1987 40.8 13867957 852. ## 9 Afghanistan Asia 1992 41.7 16317921 649. ## 10 Afghanistan Asia 1997 41.8 22227415 635. ## # ... with 1,694 more rows 5.4.1 filter() Som du ser så har gapminder 6 kolumner och 1704 rader. Vi börjar med funktionen filter() som väljer observationer baserat på deras värden. Säg att vi är intresserade av data där landet är Sverige. gapminder %&gt;% filter(country==&quot;Sweden&quot;) ## # A tibble: 12 x 6 ## country continent year lifeExp pop gdpPercap ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Sweden Europe 1952 71.9 7124673 8528. ## 2 Sweden Europe 1957 72.5 7363802 9912. ## 3 Sweden Europe 1962 73.4 7561588 12329. ## 4 Sweden Europe 1967 74.2 7867931 15258. ## 5 Sweden Europe 1972 74.7 8122293 17832. ## 6 Sweden Europe 1977 75.4 8251648 18856. ## 7 Sweden Europe 1982 76.4 8325260 20667. ## 8 Sweden Europe 1987 77.2 8421403 23587. ## 9 Sweden Europe 1992 78.2 8718867 23880. ## 10 Sweden Europe 1997 79.4 8897619 25267. ## 11 Sweden Europe 2002 80.0 8954175 29342. ## 12 Sweden Europe 2007 80.9 9031088 33860. I stället för 1704 rader har vi nu bara 12, det vill säga alla värden där kolumnen country är lika med Sverige (&quot;Sverige&quot;). 5.4.2 select() Med select väljer vi helt enkelt kolumner baserat på deras namn. Vi har i vårt data set som sagt 6 kolumner, säg att vi är intresserade av endast en kolumn, nämligen den kolumn som heter country gapminder %&gt;% select(country) ## # A tibble: 1,704 x 1 ## country ## &lt;fct&gt; ## 1 Afghanistan ## 2 Afghanistan ## 3 Afghanistan ## 4 Afghanistan ## 5 Afghanistan ## 6 Afghanistan ## 7 Afghanistan ## 8 Afghanistan ## 9 Afghanistan ## 10 Afghanistan ## # ... with 1,694 more rows I sann %&gt;%-anda kan vi självklart kombinera funktionerna. Säg att vi är intresserade av data på Sverige, och vi bara vill ha två kolumner: år och förväntad livslängd gapminder %&gt;% filter(country==&quot;Sweden&quot;) %&gt;% select(year, lifeExp) ## # A tibble: 12 x 2 ## year lifeExp ## &lt;int&gt; &lt;dbl&gt; ## 1 1952 71.9 ## 2 1957 72.5 ## 3 1962 73.4 ## 4 1967 74.2 ## 5 1972 74.7 ## 6 1977 75.4 ## 7 1982 76.4 ## 8 1987 77.2 ## 9 1992 78.2 ## 10 1997 79.4 ## 11 2002 80.0 ## 12 2007 80.9 I första steget väljer vi alla rader där country är lika med &quot;Sverige&quot; och i andra steget väljer vi kolumnerna som heter year och lifeExp. 5.4.3 mutate() med mutate() skapar vi nya kolumner baserat på befintliga kolumner. Det vill säga, vi applicerar en funktion på en eller flera befintliga kolumner och skapar en ny. Vi har BNP per capita och vi har population, så vi skulle kunna skapa en ny kolumn, gdp, genom att multiplicera gdp per capita med population, i.e. gdpPercap*pop gapminder %&gt;% mutate(gdp = gdpPercap*pop) ## # A tibble: 1,704 x 7 ## country continent year lifeExp pop gdpPercap gdp ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Afghanistan Asia 1952 28.8 8425333 779. 6567086330. ## 2 Afghanistan Asia 1957 30.3 9240934 821. 7585448670. ## 3 Afghanistan Asia 1962 32.0 10267083 853. 8758855797. ## 4 Afghanistan Asia 1967 34.0 11537966 836. 9648014150. ## 5 Afghanistan Asia 1972 36.1 13079460 740. 9678553274. ## 6 Afghanistan Asia 1977 38.4 14880372 786. 11697659231. ## 7 Afghanistan Asia 1982 39.9 12881816 978. 12598563401. ## 8 Afghanistan Asia 1987 40.8 13867957 852. 11820990309. ## 9 Afghanistan Asia 1992 41.7 16317921 649. 10595901589. ## 10 Afghanistan Asia 1997 41.8 22227415 635. 14121995875. ## # ... with 1,694 more rows "]
]
